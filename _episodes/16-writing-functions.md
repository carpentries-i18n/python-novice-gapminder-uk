## Розбийте програми на функції, щоб їх було легше зрозуміти.

*  Людина може одночасно зберігати лише кілька елементів у робочій пам’яті. 
*   Розуміти великі/складніші ідеї, розуміючи та комбінуючи їх частини.
    *   Компоненти в машині.
    *   Леми при доведенні теорем.
*   Функції служать тій же меті в програмах.
    *   *Інкапсулю.nm* складність, щоб ми могли розглядати їх як одну «річ».
*   Також уможливлюють *повторне використання*.
    *   Пишемо один раз, використовуємо багато разів..

## Визначте функцію за допомогою `def` з назвою, параметрами та блоком коду."

*   Почніть визначення нової функції з `def`.
*  Далі йде назва функції.
    *   Назви функцій мають відповідати тим самим правилам, що й імена змінних.
*   Потім *параметри* в дужках.
    *   Порожні дужки, якщо функція не приймає жодних вхідних даних.
    *   Ми наразі обговоримо це детально.
*   Потім двокрапка.
*   Потім блок коду з відступом.

~~~
def print_greeting():
    print('Hello!')
~~~
{: .language-python}

## Визначення функції не запускає її.

*   Визначення функції не запускає її.
    *   Як присвоєння значення змінній.
*   Необхідно викликати функцію, щоб виконати код, який вона містить.

~~~
print_greeting()
~~~
{: .language-python}
~~~
Hello!
~~~
{: .output}

## Аргументи у виклику зіставляються з параметрами у визначенні.

*   Функції найбільш корисні, коли вони можуть працювати з різними даними.
*   Укажіть *параметри* під час визначення функції.
    *   Вони стають змінними під час виконання функції.
    *   Праметрам присвоюються аргументи виклику (тобто значення, передані у функцію)
    *   Якщо ви не називаєте аргументи під час їх використання у виклику, аргументи будуть зіставлені з
параметрами в тому порядку, у якому вони визначені у функції.

~~~
def print_date(year, month, day):
    joined = str(year) + '/' + str(month) + '/' + str(day)
    print(joined)

print_date(1871, 3, 19)
~~~
{: .language-python}
~~~
1871/3/19
~~~
{: .output}

Або ми можемо назвати аргументи під час виклику функції, що дозволяє нам це зробити
вказати їх у довільному порядку:
~~~
print_date(month=3, day=19, year=1871)
~~~
{: .language-python}
~~~
1871/3/19
~~~
{: .output}

*   Згідно [Twitter](https://twitter.com/minisciencegirl/status/693486088963272705):
    `()` містить інгредієнти для функції
    тоді як тіло містить рецепт.

## Функції можуть повертати результат до свого виклику за допомогою `return`.

*   Використовуте `return ...` щоб повернути значення у місце виклику.
*   Може виникнути будь-де у функції.
*   Але функції легше зрозуміти, якщо реалізовано функцію `return`:
    *   На початку функції для обробки особливих випадків.
    *   У самому кінці з остаточним результатом.

~~~
def average(values):
    if len(values) == 0:
        return None
    return sum(values) / len(values)
~~~
{: .language-python}

~~~
a = average([1, 3, 4])
print('середнє фактичних значень:', a)
~~~
{: .language-python}
~~~
середнє фактичних значень: 2.6666666666666665
~~~
{: .output}

~~~
print('середнє порожнього списку:', average([]))
~~~
{: .language-python}
~~~
середнє порожнього списку: None
~~~
{: .output}

*   Пам'ятайте: [кожна функція щось повертає]({{ page.root }}/04-built-in/).
*   Функція, яка явно не містить `return` , автоматично повертає `None`.

~~~
result = print_date(1871, 3, 19)
print('результат виклику є таким:', result)
~~~
{: .language-python}
~~~
1871/3/19
результат виклику є таким: None
~~~
{: .output}

> ## Виявлення синтаксичних помилок
>
> 1. Прочитайте наведений нижче код і спробуйте визначити, у чому полягають помилки
> *без* запуску.
> 2. Запустіть код і прочитайте повідомлення про помилку.
> Це `SyntaxError` чи `IndentationError`?
> 3. Виправте помилку.
> 4. Повторюйте кроки 2 та 3 доки не виправите всі помилки.
>
> ~~~
> def another_function
> print("Syntax errors are annoying.")
> print("But at least python tells us about them!")
> print("So they are usually not too hard to fix.")
> ~~~
> {: .language-python}
>
> > ## Рішення
> >
> > ~~~
> > def another_function():
> > print("Синтаксичні помилки дратують.")
> > print("Але принаймні Python розповідає нам про них!")
> > print("Тож їх зазвичай не надто важко виправити.")
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Визначення та використання
>
> Що друкує наступна програма?
>
> ~~~
> def report(pressure):
>     print('тиск', pressure)
>
> print('виклик', report, 22.5)
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > calling <function report at 0x7fd128ff1bf8> 22.5
> > ~~~ 
> > {: .output}
> >
> > Для виклику функції завжди потрібні круглі дужки, інакше ви отримаєте адресу пам’яті об’єкта функції. Отже, якщо ми хочемо викликати функцію під назвою report і надати їй значення 22,5 для звіту, ми могли б викликати нашу функцію так
> > ~~~
> > print("виклик")
> > report(22.5)
> > ~~~
> {: .solution}
{: .challenge}


> ## Порядок виконання операцій
>
> Приклад вище:
>
> ~~~
> result = print_date(1871, 3, 19)
> print('результат виклику:', result)
> ~~~
> {: .language-python}
>
> надруковано:
> ~~~
> 1871/3/19
> результат виклику: None
> ~~~
> {: .output}
>
> Поясніть, чому два рядки виводу з’явилися в такому порядку.
>
> Що не так у цьому прикладі?
> ~~~
> result = print_date(1871,3,19)
>
> def print_date(year, month, day):
>    joined = str(year) + '/' + str(month) + '/' + str(day)
>    print(joined)
> ~~~
> {: .language-python}
> 
> > ## Рішення
> > 
> > 1. Перший рядок виводу (`1871/3/19`) є результатом функції друку всередині `print_date()`, тоді як другий рядок
> > з функції друку під викликом функції. Весь код всередині `print_date()` виконується спочатку, а потім
> > програма "залишає" функцію та виконує решту коду.   
> > 2. Проблема з прикладом полягає в тому, що функція визначається *після* виклику функції. Тому Python
> > не розуміє виклик функції.
> {: .solution}
{: .challenge}

> ## Інкапсуляція
>
> Заповніть порожні поля, щоб створити функцію, яка приймає одне ім’я файлу як аргумент,
> завантажує дані у файл, названий аргументом,
> і повертає мінімальне значення цих даних.
>
> ~~~
> import pandas as pd
>
> def min_in_data(____):
>     data = ____
>     return ____
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > import pandas as pd
> > 
> > def min_in_data(filename):
> >     data = pd.read_csv(filename)
> >     return data.min()
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Знайди Перший
>
> Заповніть порожні поля, щоб створити функцію, яка приймає список чисел як аргумент
> і повертає перше від’ємне значення в списку.
> Що робить ваша функція, якщо список порожній?
>
> ~~~
> def first_negative(values):
>     for v in ____:
>         if ____:
>             return ____
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > def first_negative(values):
> >     for v in values:
> >         if v<0:
> >             return v
> > ~~~
> > {: .language-python}
> > Якщо цій функції передається порожній список, вона повертає `None`:
> > ~~~
> > my_list = []
> > print(first_negative(my_list))
> > ~~~
> > {: .language-python}
> > ~~~
> > None
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Виклик по імені
>
> Раніше ми розглядали таку функцію:
>
> ~~~
> def print_date(year, month, day):
>     joined = str(year) + '/' + str(month) + '/' + str(day)
>     print(joined)
> ~~~
> Ми побачили, що можна викликати функцію за допомогою *іменованих аргументів*, наприклад:
> ~~~
> print_date(day=1, month=2, year=2003)
> ~~~
> {: .language-python}
>
> 1. Що друкує `print_date(day=1, month=2, year=2003)`?
> 2. Коли ви раніше бачили подібний виклик функції?
> 3. Коли і чому корисно викликати функції таким чином?
> {: .language-python}
> > ## Рішення
> > 
> > 1. `2003/2/1`
> > 2. Ми бачили приклади використання *іменованих аргументів* під час роботи з бібліотекою pandas. Наприклад, під час читання в наборі даних 
> > using `data = pd.read_csv('data/gapminder_gdp_europe.csv', index_col='country')`, останній аргумент `index_col` є 
> > іменованим аргументом.  
> > 3. Використання іменованих аргументів може зробити код більш читабельним, оскільки з виклику функції можна побачити, які імена мають різні аргументи
> > всередині функції. Це також може зменшити ймовірність передачі аргументів у неправильному порядку, оскільки за допомогою іменованих аргументів 
> > порядок не має значення.
> {: .solution}
{: .challenge}

> ## Інкапсуляція блоку If/Print
>
> Наведений нижче код запускатиметься на принтері етикеток для курячих яєць. Цифрові ваги повідомлять комп’ютеру про масу курячого яйця (у грамах), а потім комп’ютер друкує етикетку.  
>
> Будь ласка, перепишіть код так, щоб if-блок був вкладений у функцію.
>
> ~~~
>  import random
>  for i in range(10):
>
>     # імітація маси курячого яйця
>     # (випадкова) маса становитиме 70 +/- 20 грамів
>     mass=70+20.0*(2.0*random.random()-1.0)
>
>     print(mass)
>    
>     #машини для сортування яєць друкують етикетку
>     if(mass>=85):
>        print("джамбо")
>     elif(mass>=70):
>        print("велике")
>     elif(mass<70 and mass>=55):
>        print("середнє")
>     else:
>        print("мале")
> ~~~
> {: .language-python}
>
>
> Далі спрощена програма. Яке визначення функції зробить його функціональним?
>
> ~~~
>  # Адаптована версія
>  import random
>  for i in range(10):
>
>     # імітація маси курячого яйця
>     # (випадкова) маса становитиме 70 +/- 20 грамів
>     mass=70+20.0*(2.0*random.random()-1.0)
>
>     print(mass,print_egg_label(mass))    
>
> ~~~
> {: .language-python}
>
>
> 1. Створіть визначення функції для `print_egg_label()`, яка працюватиме з адаптованою програмою вище. Зверніть увагу, що чисельне значення, яке повертає функція, буде важливим. Зразок оформлення результату може мати вигляд `71.23 large`.
> 2.  Брудне яйце може мати масу понад 90 грамів, а зіпсоване чи розбите яйце, ймовірно, матиме масу менше 50 грамів. Змініть свою функцію `print_egg_label()` для врахування цих умов помилки. Вихідний зразок може бути `25 занадто легке, можливо, зіпсоване`. 
>
> > ## Рішення
> >
> > ~~~
> > def print_egg_label(mass):
> >     #egg sizing machinery prints a label
> >     if(mass>=90):
> >         return("попередження: яйце може бути брудним")
> >     elif(mass>=85):
> >         return("джамбо")
> >     elif(mass>=70):
> >         return("велике")
> >     elif(mass<70 and mass>=55):
> >         return("середнє")
> >     elif(mass<50):
> >         return("занадто легке, можливо, зіпсоване")
> >     else:
> >         return("мале")
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Інкапсуляція аналізу даних
>
> Припустімо, що наступний код було виконано:
>
> ~~~
> import pandas as pd
>
> df = pd.read_csv('data/gapminder_gdp_asia.csv', index_col=0)
> japan = df.loc['Japan']
> ~~~
> {: .language-python}
>
> 1.Заповніть наведені нижче твердження, щоб отримати середній ВВП Японії
> за роками, зазначеними у 1980-х роках.
>
> ~~~
> year = 1983
> gdp_decade = 'gdpPercap_' + str(year // ____)
> avg = (japan.loc[gdp_decade + ___] + japan.loc[gdp_decade + ___]) / 2
> ~~~
> {: .language-python}
>
> 2.Абстрагуйте код вище в одну функцію.
>
> ~~~
> def avg_gdp_in_decade(country, continent, year):
>     df = pd.read_csv('data/gapminder_gdp_'+___+'.csv',delimiter=',',index_col=0)
>     ____
>     ____
>     ____
>     return avg
> ~~~
> {: .language-python}
>
> 3.Як би ви узагальнили цю функцію
>    якщо ви не знали заздалегідь, які конкретні роки зустрічаються як стовпці в даних?
>   Наприклад, що, якби ми також мали дані за роки, що закінчуються на 1 і 9 для кожного десятиліття?
>    (Підказка: використовуйте стовпці, щоб відфільтрувати ті, що відповідають десятиліттям,
>    замість того, щоб перелічувати їх у коді.)
>
> > ## Рішення
> >
> > 1.
> >
> > ~~~
> > year = 1983
> > gdp_decade = 'gdpPercap_' + str(year // 10)
> > avg = (japan.loc[gdp_decade + '2'] + japan.loc[gdp_decade + '7']) / 2
> > ~~~
> > {: .language-python}
> >
> > 2.
> >
> > ~~~
> > def avg_gdp_in_decade(country, continent, year):
> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)
> >     c = df.loc[country]
> >     gdp_decade = 'gdpPercap_' + str(year // 10)
> >     avg = (c.loc[gdp_decade + '2'] + c.loc[gdp_decade + '7'])/2
> >     return avg
> > ~~~
> > {: .language-python}
> >
> > 3.
> > 
> > Нам потрібно переглянути звітні роки
> >  для отримання середнього значення для відповідних у даних.
> >
> > ~~~
> > def avg_gdp_in_decade(country, continent, year):
> >     df = pd.read_csv('data/gapminder_gdp_' + continent + '.csv', index_col=0)
> >     c = df.loc[country]
> >     gdp_decade = 'gdpPercap_' + str(year // 10)
> >     total = 0.0
> >     num_years = 0
> >     for yr_header in c.index: # c's index contains reported years
> >         if yr_header.startswith(gdp_decade):
> >             total = total + c.loc[yr_header]
> >             num_years = num_years + 1
> >     return total/num_years
> > ~~~
> > {: .language-python}
> > Функцію тепер можна викликати:
> > ~~~
> > avg_gdp_in_decade('Japan','asia',1983)
> > ~~~
> > {: .language-python}
> > 
> > ~~~
> > 20880.023800000003
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Моделювання динамічної системи
>
> У математиці [динамічна система](https://en.wikipedia.org/wiki/Dynamical_system) це система, у якій функція описує залежність точки в геометричному просторі від часу. Канонічним прикладом динамічної системи є система під назвою [логістичне відображення] (https://en.wikipedia.org/wiki/Logistic_map).
>
>
> 1. Визначте функцію під назвою `logistic_map`, яка приймає два входи: `x`, що представляє стан системи в момент часу _t_, і параметр `r`. Ця функція має повертати значення, що представляє стан системи в момент часу _t+1_.
>
> 2. Використовуючи цикл `for`, повторіть функцію `logistic_map`, визначену в частині 1, починаючи з початкової умови 0,5 для періодів`t_final=10`, `100`, і `1000`. Зберігайте проміжні результати в списку, щоб після завершення циклу `for` ви накопичили послідовність значень, що представляють стан `logistic_map` в моменти часу _t=0,1,...,t_final_.
>
> 3. Інкапсулюйте логіку вашого циклу `for` у функцію під назвою `iterate`, яка приймає початкову умову як перший вхід, параметр `t_final` як другий вхід і параметр `r` як третій вхід. Функція має повертати список значень, що представляють стан логістичної карти в момент часу _t=0,1,...,t_final_.
>
>
> > ## Рішення
> >
> > 1.
> >
> > ~~~
> > def logistic_map(x, r):
> >     return r * x * (1 - x)
> > ~~~
> > {: .language-python}
> >
> > 2.
> >
> > ~~~
> > initial_condition = 0.5
> > t_final = 10
> > r = 1.0
> > trajectory = [initial_condition]
> > for t in range(1, t_final):
> >     trajectory.append( logistic_map(trajectory[t-1], r) )
> > ~~~
> > {: .language-python}
> >
> > 3.
> > ~~~
> > def iterate(initial_condition, t_final, r):
> >     trajectory = [initial_condition]
> >     for t in range(1, t_final):
> >         trajectory.append( logistic_map(trajectory[t-1], r) )
> >     return trajectory
> > ~~~
> > {: .language-python} Front Matte: python-novice-gapminder/_episodes/17-scope.md:sgid "---
title: "Variable Scope"
teaching: 10
exercises: 10
questions:
- "How do function calls actually work?"
- "How can I determine where errors occurred?"
objectives:
- "Identify local and global variables."
- "Identify parameters as local variables."
- "Read a traceback and determine the file, function, and line number on which the error occurred, the type of error, and the error message."
keypoints:
- "The scope of a variable is the part of a program that can 'see' that variable."
---sgstr "змінна---
title: "Область видимості змінної"
навчання: 10
вправи: 10
питання:
- "Як насправді працюють виклики функцій?"
- "Як я можу визначити місце виникнення помилок?"
цілі:
- "Ідентифікація локальних і глобальних змінних."
- "Ідентифікація параметрів як локальних змінних."
- "Аналіз звіту системної  діагностики (Traceback) та визначення файлу, функції та номеру рядка, що містять збій, тип помилки та повідомлення про помилку"
ключові моменти:
- "Область змінної - це частина програми, яка може "бачити" цю зміну."
---
> {: .solution}
{: .challenge}

