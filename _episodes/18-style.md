## Стиль кодування

Стиль кодування допомагає нам краще зрозуміти код. Це допомагає підтримувати та змінювати код.
Python значним чином покладається на стиль кодування, як ми можемо помітити за відступами, які ми застосовуємо до рядків для визначення різних блоків коду.
Python пропонує стандартний стиль в одній із своїх перших пропозицій щодо вдосконалення Python (Python Enhancement Proposals - PEP), [PEP8](https://www.python.org/dev/peps/pep-0008), і підкреслює важливість читабельності в [Zen of Python](https://www.python.org/dev/peps/pep-0020).

Виділимо такі важливі моменти:
*  документуйте свій код
* використовуйте чіткі, зрозумілі назви змінних
* використовуйте пробіли, *не* табуляцію, для відступу рядків


## Дотримуйтеся стандартного стилю Python у своєму коді.

*   [PEP8](https://www.python.org/dev/peps/pep-0008):
    посібник зі стилю для Python, який обговорює такі теми, як імена змінних,
   як ви повинні використовувати відступи у своєму коді,
    як ви повинні структурувати ваші `import` оператори імпорту, 
   тощо.
    Дотримання PEP8 полегшує іншим розробникам Python читання та розуміння вашого коду,
    і зрозуміти, як мають виглядати їхні внески.
    Документація [Застосування PEP8 і бібліотека Python](https://pypi.python.org/pypi/pep8)
    допоможе перевірити ваш код на відповідність PEP8. 
*  Посібник [Google style guide on Python](https://google.github.io/styleguide/pyguide.html) 
   підтримує використання PEP8 та імплементує стиль кодування до більш специфічної структури
    коду Python,  теж може бути цікавим для застосування.
    Рекомендації Google [щодо форматування програмного коду,  називаються "yapf"](https://github.com/google/yapf/).

##Використовуйте твердження для перевірки внутрішніх помилок.

Твердження (Assert) — це простий, але потужний спосіб переконатися, що контекст, у якому виконується ваш код, відповідає вашим очікуванням.

~~~
def calc_bulk_density(mass, volume):
    '''Return dry bulk density = powder mass / powder volume.'''
    assert volume > 0
    return mass / volume
~~~
{: .language-python}

Якщо твердження має значення `False`, інтерпретатор Python викликає виключення `AssertionError` під час виконання програми. Вихідний код виразу, який не вдалося виконати, буде відображено як частину повідомлення про помилку. Щоб ігнорувати твердження у вашому коді, запустіть інтерпретатор із перемикачем «-O» (оптимізація). Твердження повинні містити лише прості перевірки і ніколи не змінювати стан програми. Наприклад, твердження ніколи не повинно містити присвоєння.

## Використовуйте рядки документів для надання вбудованої довідки.

*   Якщо першим у функції є рядок символів,
    який не присвоюється безпосередньо змінній,
    Python приєднує його до функції як вбудовану змінну довідки.
*   Ця змінна називається *docstring* (скорочення від «documentation string»).

~~~
def average(values):
    "Повертає середнє значення для набору величин або None, якщо набір величин не наданий."
    if len(values) == 0:
        return None
    return sum(values) / len(values)

help(average)
~~~
{: .language-python}
~~~
Help on function average in module __main__:

average(values)
    Повертає середнє зачення для набору величин або None, якщо набір величин не наданий.
~~~
{: .output}

> ## Багаторядкові рядки
>
> Часто для документації використовуються *багаторядкові рядки* .
> Вони починаються і закінчуються трьома символами лапок (одинарними або подвійними)
> і закінчується трьома відповідними символами.
>
> ~~~
> """Цей рядок охоплює
> кілька рядків.
>
> Допускаються порожні рядки."""
> ~~~
> {: .language-python}
{: .callout}

> ## Що буде показано?
>
> Виділіть рядки в коді нижче, які будуть доступні як онлайн-довідка..
> Чи є лінії, які мають бути доступні, але не будуть?
> Чи буде якийсь рядок видавати синтаксичну помилку або помилку виконання?
>
> ~~~
> "Знайти максимальну відстань редагування між кількома послідовностями."
> # Знаходить максимальну відстань між усіма послідовностями.
>
> def overall_max(sequences):
>     '''Визначає загальну максимальну відстань  редагування.'''
> 
>     highest = 0
>     for left in sequences:
>         for right in sequences:
>             '''Уникнути перевірки послідовності на саму себе.'''
>             if left != right:
>                 this = edit_distance(left, right)
>                 highest = max(highest, this)
> 
>     # Звіт.
>     return highest
> ~~~
> {: .language-python}
{: .challenge}

> ## Задокументуйте це
>
> Перетворіть коментар до наступної функції на рядок документації
> і перевірте правильність подання командою `help`.
>
> ~~~
> def middle(a, b, c):
>     # Повертає середнє значення трьох величин.
>     # У припущенні, що значення можна порівняти.
>     values = [a, b, c]
>     values.sort()
>     return values[1]
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > def middle(a, b, c):
> >     '''Повертає середнє значення трьох величин.
> >     У припущенні, що значення можна порівняти.'''
> >     values = [a, b, c]
> >     values.sort()
> >     return values[1]
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Очистіть цей код
>
> 1. Прочитайте цю коротку програму та спробуйте передбачити, що вона робить.
> 2. Запустіть програму: наскільки точним був ваш прогноз?
> 3. Проведіть рефакторинг програми, щоб зробити її більш читабельною.
>   Не забувайте запускати програми після кожної зміни, щоб переконатися, що її поведінка не змінилася.
> 4. Порівняйте свої перетворення  з результатом студента поруч.
>    Що ви зробили так само?
>    Що ви зробили інакше і чому?
>
> ~~~
> n = 10
> s = 'et cetera'
> print(s)
> i = 0
> while i < n:
>     # print('at', j)
>     new = ''
>     for j in range(len(s)):
>         left = j-1
>         right = (j+1)%len(s)
>         if s[left]==s[right]: new += '-'
>         else: new += '*'
>     s=''.join(new)
>     print(s)
>     i += 1
> ~~~
> {: .language-python}
>
> > ## Рішення
> >
> > Ось одне рішення.
> >
> > ~~~
> > def string_machine(input_string, iterations):
> >     """
> >     Бере поточну input_string і генерує новий рядок із символів -'s та *'s,
> >    - відповідає  випадку ідентичних суміжних символів
> >    в противному випадку генерується символ *. Повторює цю процедуру відповідно
> >      заданої кількості ітерацій.
> >     """
> >     print(input_string)
> >     input_string_length = len(input_string)
> >     old = input_string
> >     for i in range(iterations):
> >         new = ''
> >         # перебір символів у рядку 'old'
> >         for j in range(input_string_length):
> >             left = j-1
> >             right = (j+1) % input_string_length  # забезпечити обтікання правого індексу
> >             if old[left] == old[right]:
> >                 new += '-'
> >             else:
> >                 new += '*'
> >         print(new)
> >         # зберегти новий рядок як старий
> >         old = new     
> >
> > string_machine('et cetera', 10)
> > ~~~
> > {: .language-python}
> > 
> > ~~~
> > et cetera
> > *****-***
> > ----*-*--
> > ---*---*-
> > --*-*-*-*
> > **-------
> > ***-----*
> > --**---**
> > *****-***
> > ----*-*--
> > ---*---*-
> > ~~~
> > {: .output} Front Matte: python-novice-gapminder/_episodes/19-wrap.md:sgid "---
title: "Wrap-Up"
teaching: 20
exercises: 0
questions:
- "What have we learned?"
- "What else is out there and where do I find it?"
objectives:
- "Name and locate scientific Python community sites for software, workshops, and help."
keypoints:
- "Python supports a large and diverse community across academia and industry."
---sgstr "---
title: "Підведення підсумків"
teaching: 20
exercises: 0
questions:
- "Чому ми навчилися??"
- "Що там ще є і де це знайти?"
objectives:
- "Назвіть і знайдіть сайти наукової спільноти Python для програмного забезпечення, семінарів і допомоги."
keypoints:
- "Python підтримує велику та різноманітну спільноту в академічних і промислових колах."
---
> {: .solution}
{: .challenge}

