---
title: "Умовні оператори"
teaching: 10
exercises: 15
questions:
- "Як програми можуть робити різні речі для різних даних?
objectives:
- "Правильно писати програми, які використовують оператори if та else та прості логічні вирази (без логічних операторів)."
- "Відстежувати виконання невкладених умовних операторів і умовних операторів усередині циклів."
keypoints:
- "Використовуйте оператори if, щоб контролювати виконання блоку коду."
- "Умовні оператори часто використовуються всередині циклів."
- "Використовуйте `else` для виконання блоку коду, коли умова `if` є *не* істинною."
- "Використовуйте `elif` для визначення додаткових перевірок."
- "Умови перевіряються один раз, по порядку."
- "Створіть таблицю зі значеннями змінних для відстеження виконання програми"
---
## Використовуйте оператори if, щоб контролювати виконання блоку коду..

*   Оператор if (точніше його називають *умовним* оператором)
    контролює виконання певного блоку коду.
*   Структура подібна до оператора `for`:
    *   Перший рядок починається з `if` і закінчується двокрапкою
    *   Тіло оператору, що містить одне або кілька тверджень, має відступ (зазвичай на 4 пробіли)

~~~
mass = 3.54
if mass > 3.0:
    print(mass, 'є великим')

mass = 2.07
if mass > 3.0:
    print (mass, 'є великим')
~~~
{: .language-python}
~~~
3.54 є великим
~~~
{: .output}

## Умовні оператори часто використовуються всередині циклів.

*   Немає особливого сенсу використовувати умовний оператор, коли ми знаємо значення (як вище).
*   Але корисно, коли у нас є колекція для обробки.

~~~
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 3.0:
        print(m, 'є великим')
~~~
{: .language-python}
~~~
3.54 є великим
9.22 є великим
~~~
{: .output}

## Використовуйте `else` для виконання блоку коду, коли умова `if` є *не* істинною.

*   `else` можна використовувати після `if`.
*   Дозволяє нам вказати альтернативу для виконання, коли умова *гілки* `if` не виконується.

~~~
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 3.0:
        print(m, 'є великим')
    else:
        print(m, 'є малим')
~~~
{: .language-python}
~~~
3.54 є великим
2.07 є малим
9.22 є великим
1.86 є малим
1.71 є малим
~~~
{: .output}

## Використовуйте `elif` для визначення додаткових перевірок.

*   Може знадобитися надати кілька альтернативних варіантів, кожен зі своєю перевіркою.
*   Використовуйте `elif` (скорочення від "else if") та умову, перевірки. 
*   Завжди асоціюється з `if`.
*   Має бути перед `else` (що слугує для того, щоб "підібрати все інше").

~~~
masses = [3.54, 2.07, 9.22, 1.86, 1.71]
for m in masses:
    if m > 9.0:
        print(m, 'є ВЕЛИЧЕЗНИМ')
    elif m > 3.0:
        print(m, 'є великим')
    else:
        print(m, 'є малим')
~~~
{: .language-python}
~~~
3.54 є великим
2.07 є малим
9.22 є ВЕЛИЧЕЗНИМ
1.86 є малим
1.71 є малим
~~~
{: .output}

## Умови перевіряються один раз, по порядку.

*   Python послідовно проходить гілки умовного оператора, перевіряючи кожну по черзі.
*   Отже, порядок має значення.

~~~
grade = 85
if grade >= 70:
    print('grade is C')
elif grade >= 80:
    print('grade is B')
elif grade >= 90:
    print('grade is A')
~~~
{: .language-python}
~~~
grade is C
~~~
{: .output}

*   Автоматично *не* повертається назад і не  оцінює повторно, якщо значення змінюються.

~~~
velocity = 10.0
if velocity > 20.0:
    print('рухається занадто швидко')
else:
    print('регулювання швидкості')
    velocity = 50.0
~~~
{: .language-python}
~~~
регулювання швидкості
~~~
{: .output}

*   Умовні оператори часто використовуються  в циклі, щоб «розвинути» значення змінних.

~~~
velocity = 10.0
for i in range(5): # виконати цикл 5 разів
    print(i, ':', velocity)
    if velocity > 20.0:
        print('рухається занадто швидко')
        velocity = velocity - 5.0
    else:
        print('рухається надто повільно')
        velocity = velocity + 10.0
print('кінцева швидкість:', velocity)
~~~
{: .language-python}
~~~
0 : 10.0
рухається занадто повільно
1 : 20.0
рухається занадто повільно
2 : 30.0
рухається занадто швидко
3 : 25.0
рухається занадто швидко
4 : 20.0
рухається занадто повільно
кінцева швидкість: 30.0
~~~
{: .output}

## Створіть таблицю зі значеннями змінних для відстеження виконання програми.

<table>
  <tr>
    <td><strong>i</strong></td>
    <td>0</td>
    <td>.</td>
    <td>1</td>
    <td>.</td>
    <td>2</td>
    <td>.</td>
    <td>3</td>
    <td>.</td>
    <td>4</td>
    <td>.</td>
  </tr>
  <tr>
    <td><strong>швидкість</strong></td>
    <td>10.0</td>
    <td>20.0</td>
    <td>.</td>
    <td>30.0</td>
    <td>.</td>
    <td>25.0</td>
    <td>.</td>
    <td>20.0</td>
    <td>.</td>
    <td>30.0</td>
  </tr>
</table>

*   Програма повинна мати оператор `print` *поза* тілом циклу,
    щоб показати остаточне значення змінної `velocity`,
    оскільки її значення оновлюється останньою ітерацією циклу.

> ## Комбінація відношень з використанням «і», «або» та круглих дужок
>
> Часто потрібно, щоб певна комбінація речей була правдою. Можна комбінувати
> відносини в умовному операторі з використанням «і» та «або». Продовжуючи приклад,
> наведений вище, припустімо, що у вас є>
> ~~~
> mass     = [ 3.54,  2.07,  9.22,  1.86,  1.71]
> velocity = [10.00, 20.00, 30.00, 25.00, 20.00]
>
> i = 0
> for i in range(5):
>     if mass[i] > 5 and velocity[i] > 20:
>         print("Швидкий важкий предмет. Качка!")
>     elif mass[i] > 2 and mass[i] <= 5 and velocity[i] <= 20:
>         print("Нормальний трафік")
>     elif mass[i] <= 2 and velocity[i] <= 20:
>         print("Повільний, легкий предмет. Ігноруйте це")
>     else:
>         print("ой! Щось сталося з даними. Перевірте це")
> ~~~
> {: .language-python}
>
> Так само, як і в арифметиці, ви можете і маєте використовувати круглі дужки,
> якщо у виразі можлива двозначність. Хорошим загальним правилом є використання круглих дужок *завжди*
> при одночасному використанні `і` та `або` в однакових умовах. Тобто замість:
>
> ~~~
> if mass[i] <= 2 or mass[i] >= 5 and velocity[i] > 20:
> ~~~
> {: .language-python}
>
> напишіть одну умов нижче:
>
> ~~~
> if (mass[i] <= 2 or mass[i] >= 5) and velocity[i] > 20:
> if mass[i] <= 2 or (mass[i] >= 5 and velocity[i] > 20):
> ~~~
> {: .language-python}
>
> і тоді читачеві (і Python) цілком зрозуміло, що ви насправді маєте на увазі.
{: .callout}

> ## Відстеження виконання
>
> Що надрукує ця програма?
>
> ~~~
> pressure = 71.9
> if pressure > 50.0:
>     pressure = 25.0
> elif pressure <= 50.0:
>     pressure = 0.0
> print(pressure)
> ~~~
> {: .language-python}
>
> > ## Рішення
> >
> > ~~~
> > 25.0
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Обрізання значень
>
> Заповніть порожні поля, щоб програма створила новий список,
> що містить нулі, якщо початкові значення списку були від’ємними
> та одиниці, де початкові значення списку були додатними.
>
> ~~~
> original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]
> result = ____
> for value in original:
>     if ____:
>         result.append(0)
>     else:
>         ____
> print(result)
> ~~~
> {: .language-python}
>
> ~~~
> [0, 1, 1, 1, 0, 1]
> ~~~
> {: .output}
> > ## Рішення
> >
> > ~~~
> > original = [-1.5, 0.2, 0.4, 0.0, -1.3, 0.4]
> > result = []
> > for value in original:
> >     if value<0.0:
> >         result.append(0)
> >     else:
> >         result.append(1)
> > print(result)
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Обробка малих файлів
>
> Змініть цю програму так, щоб вона обробляла лише файли з менш ніж 50 записами.
>
> ~~~
> import glob
> import pandas as pd
> for filename in glob.glob('data/*.csv'):
>     contents = pd.read_csv(filename)
>     ____:
>         print(filename, len(contents))
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > import glob
> > import pandas as pd
> > for filename in glob.glob('data/*.csv'):
> >     contents = pd.read_csv(filename)
> >     if len(contents)<50:
> >         print(filename, len(contents))
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Ініціалізація
>
> Змініть цю програму так, щоб вона знаходила найбільше та найменше значення у списку
> незалежно від початкового діапазону значень.
>
> ~~~
> values = [...деякі тестові дані...]
> smallest, largest = None, None
> for v in values:
>     if ____:
>         smallest, largest = v, v
>     ____:
>         smallest = min(____, v)
>         largest = max(____, v)
> print(smallest, largest)
> ~~~
> {: .language-python}
>
> Які переваги та недоліки використання цього методу
> для визначення діапазону даних?
> > ## Рішення
> >
> > ~~~
> > values = [-2,1,65,78,-54,-24,100]
> > smallest, largest = None, None
> > for v in values:
> >     if smallest==None and largest==None:
> >         smallest, largest = v, v
> >     else:
> >         smallest = min(smallest, v)
> >         largest = max(largest, v)
> > print(smallest, largest)
> > ~~~
> > {: .language-python}
> {: .solution}
{: .challenge}

> ## Використання функцій з умовними операторами в Pandas
>
> Функції часто містять умови. Ось короткий приклад, в якому 
> на основі закодованих вручну значень визначається, у якому квартилі знаходиться аргумент,
> з урахуванням квартильних точок розрізу.
>
> ~~~
> def calculate_life_quartile(exp):
>     if exp < 58.41:
>         # Це спостереження належить першому квартилю
>         return 1
>     elif exp >= 58.41 and exp < 67.05:
>         # Це спостереження належить другому квартилю
>        return 2
>     elif exp >= 67.05 and exp < 71.70:
>         # Це спостереження належить третьому квартилю
>        return 3
>     elif exp >= 71.70:
>         # Це спостереження належить четвертому квартилю
>        return 4
>     else:
>         # Це спостереження має погані дані
>        return None
>
> calculate_life_quartile(62.5)
> ~~~
> {: .language-python}
>
> ~~~
> 2
> ~~~
> {: .output}
>
> Ця функція зазвичай використовується в циклі for, але Pandas має
> інший, більш ефективний спосіб робити те саме шляхом
> *застосування* функції до фрейму даних або частини фрейму даних. Розглянемо
> приклад, використовуючи наведене вище визначення функції.
>
> ~~~
> data = pd.read_csv('Americas-data.csv')
> data['life_qrtl'] = data['lifeExp'].apply(calculate_life_quartile)
> ~~~
> {: .language-python}
>
> У другому рядку є багато цікавого, тому давайте розглянемо це по частинах.
> Праворуч від `=` ми починаємо з `data['lifeExp']`, який є 
> стовпцем з позначкою `lifExp` у фреймі даних `data` .  Ми використовуємо засіб
> `apply()`, щоб виконати функцію `calculate_life_quartile` для
> визначення значень стовпця  'life_qrtl' для кожного рядку фрему даних `data`
{: .callout}

