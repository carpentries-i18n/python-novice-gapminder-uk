---
title: "Типи даних та їх перетворення"
teaching: 10
exercises: 10
questions:
- "Які типи даних зберігають програми?"
- "Як перетворити один тип в інший?"
objectives:
- "Зʼясувати, чим відрізняються цілі числа від чисел з плаваючою крапкою."
- "Зʼясувати, чим відрізняються числа та рядки символів."
- "Використовувати вбудовані функції для перетворень між цілими числами,  числами з плаваючою крапкою та рядками."
keypoints:
- "Кожне значення має тип."
- "Використовуйте вбудовану функцію `type` для визначення типу значення."
- "Типи контролюють, які операції можуть бути виконані над значеннями."
- "Рядки можна додавати та множити."
- "Рядки мають довжину (а числа - ні)."
- "Деякі операції вимагають перетворення числа у рядок або навпаки."
- "Цілі та дійсні числа можна використовувати разом для арифметичних дій."
- "Змінні можуть змінити своє значення тільки через присвоювання."
---
## Кожне значення має тип.

*   Кожне значення, яке використовує програма, має деякий тип.
*   Ціле число (`int`): зображує додатні або від’ємні цілі числа, наприклад 3 або -512.
*   Число з плаваючою крапкою (`float`): зображує дійсні числа, наприклад 3.14159 або -2.5.
*   Рядки символів (звичайно просто "рядки", `str`): представляють текст.
    *   Укладені в одинарні або подвійні лапки (тип лапок має збігатися).
    *   Під час відображення рядку лапки не друкуються.

## Вбудована функція `type` повертає тип значення.

*   Використовуйте вбудовану функцію `type`, щоб з'ясувати, який тип має значення.
*   Це також працює зі змінними.
    *   Але запамʼятайте: *значення* має свій тип, а *змінна* тільки вказує на деяке значення.

~~~
print(type(52))
~~~
{: .language-python}
~~~
<class 'int'>
~~~
{: .output}

~~~
fitness = 'average'
print(type(fitness))
~~~
{: .language-python}
~~~
<class 'str'>
~~~
{: .output}

## Тип визначає, які операції (або методи) можна виконувати із даним значенням.

*   Тип значення визначає, що може робити з ним програма.

~~~
print(5 - 3)
~~~
{: .language-python}
~~~
2
~~~
{: .output}

~~~
print('hello' - 'h')
~~~
{: .language-python}
~~~
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-2-67f5626a1e07> in <module>()
----> 1 print('hello' - 'h')

TypeError: unsupported operand type(s) for -: 'str' and 'str'
~~~
{: .error}

## Ви можете використовувати оператори "+" та "*" для дій над рядками.

*   "Додавання" рядків виконує їх конкатенацію.

~~~
full_name = 'Ahmed' + ' ' + 'Walsh'
print(full_name)
~~~
{: .language-python}
~~~
Ahmed Walsh
~~~
{: .output}

*   Якщо рядок помножити на ціле число _N_, то це створить новий рядок, який буде містити вихідний рядок, повторений  _N_ разів.
    *   Оскільки множення - це повторюване додавання.

~~~
separator = '=' * 10
print(separator)
~~~
{: .language-python}
~~~
==========
~~~
{: .output}

## Рядки мають довжину (але числа її не мають).

*   Вбудована функція `len` повертає кількість символів у рядку.

~~~
print(len(full_name))
~~~
{: .language-python}
~~~
11
~~~
{: .output}

*   Але числа не мають довжини (навіть нуль).

~~~
print(len(52))
~~~
{: .language-python}
~~~
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-3-f769e8e8097d> in <module>()
----> 1 print(len(52))

TypeError: object of type 'int' has no len()
~~~
{: .error}

## <a name='convert-numbers-and-strings'></a> Деякі операції вимагають перетворення числа у рядок або навпаки.

*   Додавання чисел та рядків неможливе.

~~~
print(1 + '2')
~~~
{: .language-python}
~~~
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-4-fe4f54a023c6> in <module>()
----> 1 print(1 + '2')

TypeError: unsupported operand type(s) for +: 'int' and 'str'
~~~
{: .error}

*   Таке додавання не дозволено, тому що воно не визначене: чи має `1 + '2'` повертати `3` чи `'12'`?
*   Перетворення типу виконується за допомогою функції, яка має те ж саме імʼя, що і потрібний тип.

~~~
print(1 + int('2'))
print(str(1) + '2')
~~~
{: .language-python}
~~~
3
12
~~~
{: .output}

## Цілі та дійсні числа можна використовувати разом.

*   Цілі та дійсні числа можна використовувати разом для арифметичних дій.
    *   Python 3 автоматично перетворить цілі числа у дійсні, якщо це потрібно. (У Python 2 ділення цілих чисел поверне ціле число, яке буде цілою частиною відповідного дійсного числа).

~~~
print('half is', 1 / 2.0)
print('three squared is', 3.0 ** 2)
~~~
{: .language-python}
~~~
half is 0.5
three squared is 9.0
~~~
{: .output}

## Змінні можуть набути своє значення тільки через присвоювання.

*   В електроних таблицях, якщо одна клітинка залежить від іншої,
    то у разі зміни у останній,
    залежна клітинка оновиться автоматично.
*   Це **не** трапляється у мовах програмування.

~~~
first = 1
second = 5 * first
first = 2
print('first is', first, 'and second is', second)
~~~
{: .language-python}
~~~
first is 2 and second is 5
~~~
{: .output}

*   Компʼютер використовує значення змінної `first` коли виконує множення,
    створює нове значення, та присвоює його змінній `second`.
*   Після цього значення `second` встановлюється на нове значення і не залежить від `first`, тому його значення не змінюється автоматично, коли змінюється значення `first`.

> ## Дроби
>
> Який тип має число 3.4?
> Як це можна встановити?
>
> > ## Рішення
> >
> > Це - дійсне число (або число з плаваючою крапкою).
> >
> > ~~~
> > print(type(3.4))
> > ~~~
> > {: .language-python}
> > ~~~
> > <class 'float'>
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Автоматичне перетворення типів
>
> Який тип має 3.25 + 4?
>
> > ## Рішення
> >
> > Це - дійсне число:
> > цілі числа автоматично перетворюються у дійсні, коли це необхідно.
> >
> > ~~~
> > result = 3.25 + 4
> > print(result, 'is', type(result))
> > ~~~
> > {: .language-python}
> > ~~~
> > 7.25 is <class 'float'>
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Вибір типу
>
> Який тип (ціле число, дійсне число, рядок символів) ви будете використовувати для зберігання наступних значень? Спробуйте надати більш ніж одну відповідь у кожному випадку. Наприклад, в питанні # 1, коли для рахування днів дійсні числа можуть бути більш доречними, ніж цілі?  
>
> 1. Кількість днів з початку року.
> 2. Час, який пройшов з початку року до поточного моменту, у днях.
> 3. Серійний номер лабораторного обладнання.
> 4. Вік лабораторного зразка.
> 5. Чисельність населення міста.
> 6. Середня чисельність населення міста за певний час.
>
> > ## Рішення
> >
> > Ці питання мають наступні відповіді:
> > 1. Ціле число, оскільки кількість днів приймає значення від 1 до 365. 
> > 2. Дійсне число, оскільки треба використовувати частини дня.
> > 3. Рядок символів, якщо серійний номер містить букви та цифри; ціле число, якщо він містить тільки цифри.
> > 4. Це залежить від багатьох факторів! Як вимірюється вік зразка? Кількість днів з моменту, коли його було виготовлено (ціле число)? Дата і час (рядок)?
> > 5. Виберіть дійсне число, щоб представити приблизну кількість населення за допомогою округлення (наприклад, до мільйонів), або ціле число, щоб представити точну кількість населення.
> > 6. Дійсне число, оскільки результат усереднення, швидше за все, буде мати дрібну частину.
> > {: .output}
> {: .solution}
{: .challenge}

> ## Типи операцій ділення 
>
> У Python 3 оператор `//` виконує ціле ділення (повертає цілу частину результату), оператор `/` виконує ділення з плаваючою крапкою,
> та оператор '%' (або *модуль*) повертає залишок від цілого ділення:
>
> ~~~
> print('5 // 3:', 5//3)
> print('5 / 3:', 5/3)
> print('5 % 3:', 5%3)
> ~~~
> {: .language-python}
>
> ~~~
> 5 // 3: 1
> 5 / 3: 1.6666666666666667
> 5 % 3: 2
> ~~~
> {: .output}
>
> Але у Python 2 (та інших мовах) оператор `/` для двох цілих чисел буде виконувати ціле (`//`) ділення. Щоб виконати ділення з плаваючою крапкою, треба перетворити одне з цілих чисел на дійсне.
>
> ~~~
> print('5 // 3:', 1)
> print('5 / 3:', 1 )
> print('5 / float(3):', 1.6666667 )
> print('float(5) / 3:', 1.6666667 )
> print('float(5 / 3):', 1.0 )
> print('5 % 3:', 2)
> ~~~
>
> Нехай `num_subjects` - це загальне число людей, які беруть участь у дослідженні,
> а `num_per_survey` - це число людей, які можуть взяти участь у одному опитуванні.
> Як обчислити кількість досліджень, необхідну,
> щоб опитати кожного один раз?
>
> > ## Рішення
> > Нам треба знайти мінімальну кількість опитувань, необхідну, щоб опитати кожного один раз, тобто
> > округлити до більшого цілого числа `num_subjects / num_per_survey`. Це
> > еквивалентно виконанню цілого ділення за допомогою `//` з додаванням  1.
> > ~~~
> > num_subjects = 600
> > num_per_survey = 42
> > num_surveys = num_subjects // num_per_survey + 1
> >
> > print(num_subjects, 'subjects,', num_per_survey, 'per survey:', num_surveys)
> > ~~~
> > {: .language-python}
> > ~~~
> > 600 subjects, 42 per survey: 15
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Перетворення рядків у числа
>
> Коли доцільно, `float()` перетворить рядок на число з плаваючою крапкою,
> а `int()` перетворить число з плаваючою крапкою на ціле:
>
> ~~~
> print("string to float:", float("3.4"))
> print("float to int:", int(3.4))
> ~~~
> {: .language-python}
>
> ~~~
> string to float: 3.4
> float to int: 3
> ~~~
> {: .output}
>
> Однак якщо перетворення не має сенсу, то зʼявиться повідомлення про помилку
>
> ~~~
> print("string to float:", float("Hello world!"))
> ~~~
> {: .language-python}
>
> ~~~
> ---------------------------------------------------------------------------
> ValueError                                Traceback (most recent call last)
> <ipython-input-5-df3b790bf0a2> in <module>()
> ----> 1 print("string to float:", float("Hello world!"))
>
> ValueError: could not convert string to float: 'Hello world!'
> ~~~
> {: .error}
>
> Беручи це до уваги, чого ви чекаєте від наступної програми?
>
> Що вона робить насправді?
>
> Як це пояснити?
>
> ~~~
> print("fractional string to int:", int("3.4"))
> ~~~
> {: .language-python}
> 
> > ## Рішення
> > Чого можна очікувати від цієї програми? Чому б не очікувати, що у Python 3 команда `int` 
> > перетворить рядок "3.4" на 3.4 та виконає додаткове перетворення у ціле число 3. Зрештою, Python 3 створює багато іншої
> > магії - хіба це не частина його чарівності?
> > 
> > Однак Python 3 видає помилку. Чому? Можливо, щоб бути послідовним. Якщо ви просите Python виконати два послідовних
> > перетворення типу, ви маєте явним чином вказати це у коді програми.
> >
> > ~~~
> > int("3.4")
> > int(float("3.4"))
> > ~~~
> > {: .language-python}
> > ~~~
> > In [2]: int("3.4")
> > ---------------------------------------------------------------------------
> > ValueError                                Traceback (most recent call last)
> > <ipython-input-2-ec6729dfccdc> in <module>()
> > ----> 1 int("3.4")
> > ValueError: invalid literal for int() with base 10: '3.4'
> > 3
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Арифметичні дії з різними типами
>
> Яка з наступних команд поверне дійсне число `2.0`?
> Примітка: це питання може мати декілька коректних відповідей.
>
> ~~~
> first = 1.0
> second = "1"
> third = "1.1"
> ~~~
> {: .language-python}
>
> 1. `first + float(second)`
> 2. `float(second) + float(third)`
> 3. `first + int(third)`
> 4. `first + int(float(third))`
> 5. `int(first) + int(float(third))`
> 6. `2.0 * second`
>
> > ## Рішення
> >
> > Відповідь: 1 та 4
> {: .solution}
{: .challenge}

> ## Комплексні числа
>
> Python підтримує комплексні числа,
> які записуються як `1.0+2.0j`.
> Якщо `val` - комплексне число,
> то до його дійсної та уявної частин можна отримати доступ за допомогою *крапкової нотації*
> як `val.real` та `val.imag`.
>
> ~~~
> complex = 6 + 2j
> print(complex.real)
> print(complex.imag)
> ~~~
> {: .language-python}
>
> ~~~
> 6.0
> 2.0
> ~~~
> {: .output}
>
>
> 1.  Чому, на вашу думку, Python використовує `j` замість `i` для уявної частини?
> 2.  Що ви очікуєте отримати від `1+2j + 3`?
> 3.  Що ви очікуєте від `4j`?  А що від `4 j` або `4 + j`?
> 
> > ## Рішення
> >
> > 1. Стандартні математичні позначення зазвичай використовують `i` для позначення комплексного числа. Однак, судячи з різних джерел, це
> > було раннє позначення, яке використовувалось у електротехніці, та зараз було б дуже дорого його
> > змінити. [Stack Overflow містить додаткові пояснення та
> > обговорення.](http://stackoverflow.com/questions/24812444/why-are-complex-numbers-in-python-denoted-with-j-instead-of-i)
> > 2. `(4+2j)`
> > 3. `4j`, `Syntax Error: invalid syntax`, у цьому випадку _j_ вважається змінною, і це залежить від того, чи визначене _j_, і якщо так, то його присвоєне значення
> {: .solution}
{: .challenge}

