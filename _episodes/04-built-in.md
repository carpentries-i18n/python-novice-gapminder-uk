---
title: "Вбудовані функції та довідка"
teaching: 15
exercises: 10
questions:
- "Як я можу використовувати вбудовані функції?"
- "Як я можу дізнатися, що вони роблять?"
- "Які помилки можуть виникати в програмах?"
objectives:
- "Пояснення призначення функцій."
- "Коректний виклик вбудованих функцій Python."
- "Коректний виклик вкладених вбудованих функцій."
- "Використання довідки для перегляду документації про вбудовані функції."
- "Правильний опис ситуації, в яких виникають SyntaxError і NameError"
keypoints:
- "Використання коментарів при створенні документації програм."
- "Функція без аргументів та функція з довільною кількістю аргументів."
- "Поширені вбудовані функції `max`, `min` та `round`."
- "Функції можуть працювати лише з певними аргументами (комбінаціями аргументів)."
- "Функції можуть мати значення за замовчуванням для певних аргументів."
- "Використання вбудованої функції `help` для отримання довідки про функції".
- "Два шляхи отримання допомоги у Jupyter Notebook."
- "Кожна функція щось повертає."
- "Python повідомляє про синтаксичну помилку, коли джерело програми не зрозуміле."
- "Python повідомляє про помилку виконання, коли щось йде не так під час компілювання програми."
- "Виправлення синтаксичних помилок у процесі читання вихідного коду, а помилок виконання - у процесі компіляції програми."
## Використання коментарів при створенні документації програм.

~~~
# Цю строку Python не виконує.
adjustment = 0.5   # Усе після '#' ігнорується.
~~~
{: .language-python}

## Функції можуть сприймати нуль або деяку кількість аргументів.

*   Ми вже бачили деякі функції --- тепер розглянемо їх ближче.
*   *Аргумент* - це значення, яке передається у функцію.
*   `len` в якості аргумента використовує точне значення.
*   `int`, `str` та `float` створюють нові значення з існуючих.
*   `print` в якості аргументу може використовувати як нульове, так і ненульове значення.
*   `print` без аргументів повертає порожній рядок.
    *   Необхідно завжди використовувати дужки, навіть якщо вони порожні,
        щоб Python розумів, що викликається функція.

~~~
print('before')
print()
print('after')
~~~
{: .language-python}
~~~
before

after
~~~
{: .output}

## Поширені вбудовані функції `max`, `min` та `round`.

*   Використовуйте `max`, щоб знайти найбільше з одного або декількох значень.
*   Використовуйте `min`, щоб знайти найменше значення.
*   Обидві функції в якості аргументу можуть використовувати як символьний рядок, так і число.
    *   Для порівняння літер використовуйте «Більші» та «менші» (0-9, A-Z, a-z) літери.

~~~
print(max(1, 2, 3))
print(min('a', 'A', '0'))
~~~
{: .language-python}
~~~
3
0
~~~
{: .output}

## Функції можуть працювати лише з певними аргументами (комбінаціями аргументів).

*   `max` та `min` повинні мати принаймні один аргумент.
    *   "Найбільше значення з порожньої множини" - запит, який не має сенсу.
*   Крім того, аргументи функції повинні бути зіставні, щоб їх можна було порівнювати.

~~~
print(max(1, 'a'))
~~~
{: .language-python}
~~~
TypeError                                 Traceback (most recent call last)
<ipython-input-52-3f049acf3762> in <module>
----> 1 print(max(1, 'a'))

TypeError: '>' not supported between instances of 'str' and 'int'
~~~
{: .error}

## Функції можуть мати значення за замовчуванням для певних аргументів.

*   `round` округляє число з плаваючою крапкою.
*   За замовчуванням округлює до нуля знаків після крапки.

~~~
round(3.712)
~~~
{: .language-python}
~~~
4
~~~
{: .output}

*   Ми можемо вказати потрібну кількість десяткових знаків.

~~~
round(3.712, 1)
~~~
{: .language-python}
~~~
3.7
~~~
{: .output}

## Використовуйте вбудовану функцію `help`, щоб отримати довідку щодо функції.

*   Кожна вбудована функція має онлайн-документацію.

~~~
help(round)
~~~
{: .language-python}
~~~
Допомога щодо вбудованих функцій у модулі builtins:

round(number, ndigits=None)
    Округлення числа до заданої точності в десяткових цифрах.

    Повернене значення є цілим числом, якщо ndigits опущено - None.  Інакше
    значення, що повертається, має той самий тип, що й число. ndigits може бути від'ємним.
~~~
{: .output}

## Python повідомляє про синтаксичну помилку, коли він не може зрозуміти джерело програми.

*   Він навіть не намагатиметься запустити програму, якщо її неможливо коректно прочитати.

~~~
# Рядок не взято в лапки.
name = 'Feng
~~~
{: .language-python}
~~~
  File "<ipython-input-56-f42768451d55>", line 2
    name = 'Feng
                ^
SyntaxError: EOL while scanning string literal
~~~
{: .error}

~~~
# Додатковий знак '=' у присвоєнні.
age = = 52
~~~
{: .language-python}
~~~
   File "<ipython-input-57-ccc3df3cf902>", line 2
    age = = 52
          ^
SyntaxError: invalid syntax
~~~
{: .error}

*   Подивіться уважніше на повідомлення про помилку:

~~~
print("hello world"
~~~
{: .language-python}
~~~
  File "<ipython-input-6-d1cc229bf815>", line 1
    print ("hello world"
                        ^
SyntaxError: unexpected EOF while parsing
~~~
{: .error}

*   Повідомлення вказує на проблему в першому рядку введеної програми ("line 1").
    *   У цьому випадку розділ імені файлу «ipython-input» повідомляє нам, що 
        ми працюємо з введенням в IPython,
        з інтерпретатором Python, який використовується в Jupyter Notebook.
*   Частина `-6-` в назві файлу вказує на те, що
    помилка сталася в клітинці 6.
*   Далі йде проблемний рядок коду,
    на що вказує символ `^`.

## <a name='runtime-error'></a> Python повідомляє про помилку "runtime error", коли щось йде не так під час виконання програми.

~~~
age = 53
remaining = 100 - aege # неправильно написано 'age'
~~~
{: .language-python}
~~~
NameError                                 Traceback (most recent call last)
<ipython-input-59-1214fb6c55fc> в <module>
      1 age = 53
----> 2 remaining = 100 - aege # неправильно написано 'age'

NameError: name 'aege' is not defined
~~~
{: .error}

*   Якщо перечитаєте джерело, можна виправити синтаксичні помилки, а якщо відстежите компілювання - помилки виконання.

## Два шляхи отримання допомоги у Jupyter Notebook.

*   Розмістіть курсор у будь-якому місці виклику функції
    (тобто в імені функції або її параметрах),
    утримуйте `shift`
    та натисніть `tab`.
*   Або введіть назву функції зі знаком питання після неї.

## Кожна функція щось повертає.

*   Кожен виклик функції дає певний результат.
*   Якщо функція не повертає корисного результату,
    зазвичай вона повертає спеціальне значення `None`.

~~~
result = print('example')
print('result of print is', result)
~~~
{: .language-python}
~~~
example
result of print is None
~~~
{: .output}

> ## Що відбувається?
>
> 1. Поясніть простими словами порядок операцій у наступній програмі:
>    коли відбувається додавання, коли відбувається віднімання,
>    коли викликається кожна функція тощо.
> 2. Яке кінцеве значення величини `radiance`?
>
> ~~~
> radiance = 1.0
> radiance = max(2.1, 2.0 + min(radiance, 1.1 * radiance - 0.5))
> ~~~
> {: .language-python}
> > ## Рішення
> > 1.
> >    1. `1.1 * radiance = 1.1`
> >    2. `1.1 - 0.5 = 0.6`
> >    3. `min(radiance, 0.6) = 0.6`
> >    4. `2.0 + 0.6 = 2.6`
> >    5. `max(2.1, 2.6) = 2.6`
> > 2. В підсумку, `radiance = 2.6`
> {: .solution}
{: .challenge}

> ## Знайдіть відмінності
>
> 1. Подумайте, що виведе кожен з операторів `print` у наведеній нижче програмі.
> 2. Функція `max(len(rich), poor)` поверне відповідь або повідомлення про помилку?
>    Якщо поверне відповідь, чи буде вона мати сенс?
>
> ~~~
> easy_string = "abc"
> print(max(easy_string))
> rich = "gold"
> poor = "tin"
> print(max(rich, poor))
> print(max(len(rich), len(poor)))
> ~~~
> {: .language-python}
> > ## Рішення
> > ~~~
> > print(max(easy_string))
> > ~~~
> > {: .language-python}
> > ~~~
> > c
> > ~~~
> > {: .output}
> > ~~~
> > print(max(rich, poor))
> > ~~~
> > {: .language-python}
> > ~~~
> > tin
> > ~~~
> > {: .output}
> > ~~~
> > print(max(len(rich), len(poor)))
> > ~~~
> > {: .language-python}
> > ~~~
> > 4
> > ~~~
> > {: .output}
> > `max(len(rich), poor)` поверне TypeError. Це станеться на `max(4, 'tin')` і, 
> > як ми говорили раніше, порівнювати рядок і ціле число не можна.
> > ~~~
> > TypeError                                 Traceback (most recent call last)
> > <ipython-input-65-bc82ad05177a> в <module>
> > ----> 1 max(len(rich), poor)
> > 
> > TypeError: '>' not supported between instances of 'str' and 'int'
> > ~~~
> > {: .error }
> {: .solution}
{: .challenge}

> ## Чому ні?
>
> Чому функції `max` і `min` не повертають `None`, якщо їм не надано аргументів?
>
> > ## Рішення
> > `max` і `min` у цьому випадку повертають TypeErrors, оскільки правильна кількість параметрів
> > не була надана. Якби функції повернули тільки `None`, таку помилку було б набагато важче відстежити.
> > Швидше за все, значення `None` буде збережено у змінній і використано пізніше в програмі лише для того, щоб повернути
> > помилку виконання.
> {: .solution}
{: .challenge}

> ## Останній символ рядка
>
> Якщо Python починає рахувати з нуля,
> та `len` повертає кількість символів у рядку,
> то який індекс отримає останній символ у рядку `name`?
> (Примітка: ми побачимо простіший спосіб зробити це в наступному епізоді.)
>
> > ## Рішення
> >
> > `name[len(name) - 1]`
> {: .solution}
{: .challenge}

