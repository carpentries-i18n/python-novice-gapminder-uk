---
title: "Змінні та присвоєння"
teaching: 10
exercises: 10
questions:
- "Як я можу зберігати дані в програмах?"
objectives:
- "Написати програми, які присвоюють скалярні значення змінним і виконують обчислення з цими значеннями."
- "Правильнo відстежувати зміни значень у програмах, які використовують скалярне присвоєння."
keypoints:
- "Використовуйте змінні для зберігання значень."
- "Використовуйте `print` для відображення значень."
- "Змінні зберігаються між клітинками."
- "Змінні мають бути створені перед їх використанням."
- "Змінні можна використовувати в обчисленнях."
- "Використовуйте індекс, щоб отримати один символ із рядка."
- "Використовуйте зріз, щоб отримати підрядок."
- "Використовуйте вбудовану функцію `len`, щоб знайти довжину рядка."
- "Python чутливий до регістру."
- "Використовуйте змістовні імена змінних."
---
## Використовуйте змінні для зберігання значень.

*   **Змінні** - це назви значень.
*   У Python символ `=` використовується для присвоювання значення, яке знаходиться праворуч, до її назви, яка вказана ліворуч.
*   Змінна створeна, коли ій присвоюється значення.
*   Нижче, Python присвоює рік змінній `age`
    та ім'я у лапках - змінній `first_name`.

~~~
age = 42
first_name = 'Ahmed'
~~~
{: .language-python}

*  Назви змінних
    * можуть **тільки** складатися з букв, цифр та підкреслення `_` (яке звичайно використовується щоб відокремити слова у довгих назвах змінних)
    * не можуть починатися з цифри
    * **залежать від регістру** (тобто `age`, `Age` та `AGE` - це три різні змінні)
*   Назви змінних які починаються з підкреслення, як наприклад `__alistairs_real_age`, мають спеціальне значення,
    і тому ми не будемо використовувати їх, доки не зрозуміємо цього правила.

## Використовуйте `print` для виводу значень.

*   Python має вбудовану функцію `print`, яка друкує щось як текст.
*   Щоб викликати функцію (тобто, щоб виконати її), треба вказати її ім'я.
*   Щоб передати функції значення (тобто, те що треба надрукувати), їх треба помістити у дужки.
*   Щоб додати до друку рядок тексту, його треба помістити у одинарні або подвійні лапки.
*  Значення, які передаються до функції, називаються **аргументами**

~~~
print(first_name, 'is', age, 'years old')
~~~
{: .language-python}
~~~
Ahmed is 42 years old
~~~
{: .output}

*   `print` автоматично додає пропуск проміж надрукованими аргументами, щоб розділити їх.
*   Також `print` переходить на новий рядок після друку.

## Змінні мають бути створені перед їх використанням.

*   Якщо змінна не їснує, або її назва написана з помилкою,
    Python видасть помилку. (На відміну від деяких іншіх мов, які можуть "вгадати" якесь значення за замовчуванням.)

~~~
print(last_name)
~~~
{: .language-python}
~~~
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-1-c1fbb4e96102> in <module>()
----> 1 print(last_name)

NameError: name 'last_name' is not defined
~~~
{: .error}

*   Звичайно, останній рядок у повідомленні про помилку є найбільш інформативним.
*   Ми подивимось більш детально на повідомлення про помилки [пізніше]({{ page.root }}/15-scope/#reading-error-messages).

> ## Змінні зберігаються між клітинками
>
> Майте на увазі, що в блокноті Jupyter важливий *порядок* виконання клітинок, а не порядок 
> їх появи. Python запам’ятає *весь* код, який було запущено раніше, включно з будь-якими змінними, 
> які ви визначили, незалежно від порядку в блокноті. Тому, якщо ви визначите змінні нижче блокнота, а потім
> (повторно) запустите комірки вище, ті, що визначені нижче, все одно будуть присутні. 
Для прикладу створіть дві клітинки з 
таким вмістом у такому порядку:

>
> ~~~
> print(myval)
> ~~~
> {: .language-python}
>
> ~~~
> myval = 1
> ~~~
> {: .language-python}
>
>Якщо ви виконуєте це по порядку, перша клітинка дасть помилку. Однак якщо ви запустите першу клітинку *після* другої,
> то буде надруковано `1`. Щоб уникнути плутанини, може бути корисним скористатися опцією `Kernel` -> `Restart & Run All`, яка
> очищає інтерпретатор і запускає все з чистого листа зверху вниз. 
{: .callout}

## Змінні можна використовувати для обчислень.

*   Ми можемо використовувати змінні в обчисленнях так само, як якщо б вони були значеннями.
    *   Пам’ятайте, ми присвоїли значення `42` змінній `age` кількома рядками вище.

~~~
age = age + 3
print('Вік через три роки:', age)
~~~
{: .language-python}
~~~
Вік через три роки: 45
~~~
{: .output}

## Використовуйте індекс, щоб отримати один символ із рядка.

*   Символи (окремі літери, цифри тощо) у рядку є
    упорядкованими. Наприклад, рядок `'AB'` не те саме, що `'BA'`. Завдяки
  такому упорядкуванню ми можемо розглядати рядок як список символів.
*   Кожна позиція в рядку (перша, друга тощо) має номер. Це
число називається **індексом** або іноді нижнім індексом.
*   Індекси нумеруються від 0.
*   Dикористовуйте індекс позиції в квадратних дужках,  щоб отримати символ з тієї 
    позиції.

![an illustration of indexing](../fig/2_indexing.svg)

~~~
atom_name = 'helium'
print(atom_name[0])
~~~
{: .language-python}
~~~
h
~~~
{: .output}

## Використовуйте зріз, щоб отримати підрядок.

* Частина рядка має назву **підрядок**. Підрядок може бути дуже коротким - 
лише один символ.
* Список складається з елементів. У випадку, коли рядок розглядається як
список, його елементами є окремі символи.
* Фрагмент - це частина рядка (в загальному випадку, будь-який вираз).
* Фрагмент вилучається за допомогою `[start:stop]`, де `start` замінюється на
індекс елемента, який повинен бути першим, а `stop` - на індекс
елемента, який розташований відразу після останнього потрібного елемента.
* З математичної точки зору, фрагмент вибирає `[start:stop)`.
* Проміжок між `stop` and `start` - це довжина фрагмента.
* Вилучення фрагмента не змінює вміст вихідного рядка. Навпаки,
фрагмент буде копією частини вихідного рядка.

~~~
atom_name = 'sodium'
print(atom_name[0:3])
~~~
{: .language-python}
~~~
sod
~~~
{: .output}

## Використовуйте вбудовану функцію `len`, щоб знайти довжину рядка.

~~~
print(len('helium'))
~~~
{: .language-python}
~~~
6
~~~
{: .output}

*   Вкладені функції опрацьовуються, починаючи з середини,
     як в математиці.

## Python чутливий до регістру.

*   Python вважає, що великі та малі літери різні,
    таким чинoм, `Name` та `name` є різними змінними.
*   Існують угоди про використання великих літер на початку імен змінних, тому ми будемо використовувати малі літери.

## Використовуйте осмислені назви змінних.

*   Python байдуже, як ви називаєте змінні, якщо вони підкоряються правилам
    (букви, цифри та підкреслення).

~~~
flabadab = 42
ewr_422_yY = 'Ahmed'
print(ewr_422_yY, 'is', flabadab, 'years old')
~~~
{: .language-python}

*   Використовуйте змістовні назви змінних, щоб допомогти іншим зрозуміти, що робить програма.
*   Найважливіша «інша людина» — це ваше майбутнє.

> ## Заміна значень
>
> Заповніть таблицю, вказавши значення змінних у цій програмі
> *після* виконання кожного оператора.
>
> ~~~
> # Оператор  # Значення x   # Значення y   # Значення  swap #
> x = 1.0    #              #              #               #
> y = 3.0    #              #              #               #
> swap = x   #              #              #               #
> x = y      #              #              #               #
> y = swap   #              #              #               #
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > # Оператор # Значення x # Значення y # Значення swap #
> > x = 1.0    # 1.0          # не визначено  # не визначено   #
> > y = 3.0    # 1.0          # 3.0          # не визначено   #
> > swap = x   # 1.0          # 3.0          # 1.0           #
> > x = y      # 3.0          # 3.0          # 1.0           #
> > y = swap   # 3.0          # 1.0          # 1.0           #
> > ~~~
> > {: .output}
> > 
> > Ці три рядки обмінюються значеннями в `x` та `y` за допомогою `swap`
> > змінна для тимчасового зберігання. Це досить поширена ідіома програмування.
>{: .Рішення}
{: .challenge}

> ## Прогнозування значень
>
> Яке кінцеве значення `position` у наведеній нижче програмі?
> (Спробуйте передбачити значення без запуску програми,
> а потім перевірте свій прогноз.)
>
> ~~~
> initial = 'left'
> position = initial
> initial = 'right'
> ~~~
> {: .language-python}
> > ## Рішення
> >
> > ~~~
> > 'left'
> > ~~~
> > {: .output}
> >
>> Змінній `initial` присвоюється значення `'left``.
> > У другому рядку змінна `position` також отримує
>> значення рядка `'left'`. У третьому рядку змінній `initial` надається
>> значення `'right'`, але змінна `position` зберігає своє рядкове значення
>> `'left'`.
>{: .Рішення}
{: .challenge}

> ## Випробування
>
> Якщо ви призначите `a = 123`,
> що станеться, якщо ви спробуєте отримати другу цифру `a` через `a[1]`
>
> > ## Рішення
> > Числа не є рядками чи послідовностями, і Python поверне помилку, якщо ви спробуєте виконати операцію індексу на
> > числі. У [наступному уроці про типи та перетворення типів]({{ page.root }}/03-types-conversion/#convert-numbers-and-strings)
> > ми дізнаємося більше про типи та як конвертувати між різними типами. Якщо вам потрібна N-та цифра числа, ви
> > може перетворити його на рядок за допомогою вбудованої функції `str`, а потім виконати операцію індексування цього рядка.
> >
> > ~~~
> > a = 123
> > print(a[1])
> > ~~~
> > {: .language-python}
> > ~~~
> > TypeError: 'int' object is not subscriptable
> > ~~~
> > {: .error}
> > 
> > 
> > ~~~
> > a = str(123)
> > print(a[1])
> > ~~~
> > {: .language-python}
> > ~~~
> > 2
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Вибір імені
>
> Яка назва змінної є кращою: `m`, `min` або `minutes`?
> Чому?
> Підказка: подумайте, який код ви б хотіли успадкувати
> від когось, хто виходить з лабораторії:
>
> 1. `ts = m * 60 + s`
> 2. `tot_sec = min * 60 + sec`
> 3. `total_seconds = minutes * 60 + seconds`
>
> > ## Рішення
> >
> > `хвилини` краще, тому що `min` може означати щось на зразок "мінімум"
> > (і фактично це існуюча вбудована функція в Python, яку ми розглянемо пізніше).
> {: .solution}
{: .challenge}

> ## Практика застосування зрізів
>
> Що надрукує наступна программа?
>
> ~~~
> atom_name = 'carbon'
> print('atom_name[1:3] is:', atom_name[1:3])
> ~~~
> {: .language-python}
>
> > ## Рішення
> >
> > ~~~
> > atom_name[1:3] is: ar
> > ~~~
> > {: .output}
> {: .solution}
{: .challenge}

> ## Визначення зрізів
>
> 1.  Що є результатом зрізу `thing[low:high]`?
> 2.  Що є результатом зрізу `thing[low:]` (без значення після двокрапки)?
> 3.  Що є результатом зрізу `thing[:high]` (без значення до двокрапки) ?
> 4.  Що є результатом зрізу `thing[:]` (тільки двокрапка)?
> 5.  Що є результатом зрізу `thing[number:some-negative-number]`?
> 6.  Що станеться, якщо ми оберемо значення `high`, яке виходить за рамки діапазону? (наприклад, спробуйте `atom_name[0:15]`) 
>
> > ## Рішення
> >
> > 1. `thing[low:high]` поверне зріз, починаючи із значення `low` до значення перед `high`
> > 2. `thing[low:]` поверне зріз, починаючи із значення `low`, що містить всі значення до кінця `thing`
> > 3. `thing[:high]` поверне зріз, починаючи з початку `thing` до значення перед `high`
> > 4. `thing[:]` поверне всі значення рядка `thing`
> > 5. `thing[number:some-negative-number]` поверне зріз, починаючи зі значення `number` до значення `some-negative-number`, що обраховується з кінця рядка `thing`
> > 6. Якщо частина фрагмента виходить за межі діапазону, операція не завершується. `atom_name[0:15]` дає той самий результат, що й`atom_name[0:]`.
> {: .solution}
{: .challenge}

